/** * Main logging class *  * @author john */package com.newgonzo.commons.logging{	import com.newgonzo.commons.utils.*;	public class Log	{		private static var targets:Array = new Array();		private static var loggers:Array = new Array();				private static var loggerFactory:LoggerFactory = new LoggerFactory();				public static function setLoggerFactory(factory:LoggerFactory):void		{			loggerFactory = factory;		}				public static function addTarget(target:ILoggingTarget):void		{			var filter:RegExp = target.filter;			var logger:ILogger;			var i:int = loggers.length; 								while(i--)			{				logger = loggers[i] as ILogger;								if(!filter || logger.category.search(filter) != -1)				{					target.addLogger(logger);				}			}			targets.push(target);		}				public static function removeTarget(target:ILoggingTarget):void		{			ArrayUtil.extract(targets, target);						var i:int = loggers.length; 						while(i--)			{				target.removeLogger(loggers[i]);			}		}		public static function getLogger(owner:*):ILogger		{			var category:String;						if(owner is String)			{				category = owner;			}			else			{				category = ClassUtil.getClassName(owner);			}						var i:int = loggers.length;						while(i--)			{				if(loggers[i].category == category)				{					return loggers[i];				}			}						// If the logger wasn't previously found, create it and add it					var logger:ILogger = loggerFactory.createLogger(category);						loggers.push(logger);						// all of our targets must be associated with this logger			var target:ILoggingTarget;			var j:int = targets.length;						while(j--)			{				target = targets[j] as ILoggingTarget;								if(!target.filter || logger.category.search(target.filter) != -1)				{					target.addLogger(logger);				}			}						return logger;		} 		public static function flush():void		{			var i:int = loggers.length;						while(i--)			{				var j:int = targets.length;								while(j--)				{					targets[j].removeLogger(loggers[i]);				}			}						loggers = new Array();		}				public static function isDebug():Boolean		{			return willLog(LogEventLevel.DEBUG);		}				public static function isError():Boolean		{			return willLog(LogEventLevel.ERROR);		}				public static function isFatal():Boolean		{			return willLog(LogEventLevel.FATAL);		}				public static function isInfo():Boolean		{			return willLog(LogEventLevel.INFO);		}				public static function isWarn():Boolean		{			return willLog(LogEventLevel.WARN);		}				private static function willLog(level:int):Boolean		{			var i:int = targets.length;						while(i--)			{				if(targets[i].level <= level)				{					return true;				}			}						return false;		}	}	}